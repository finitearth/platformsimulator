package model;

import java.io.Serializable;
import java.util.LinkedList;

import main.Logger;

/**
 * This class represents a platform, controlled by a group of students or a single student.
 */
public class Player implements Serializable {

	private static final long serialVersionUID = 1L;
	
	String name;
	Division division;					// The division the platform is active on (used to pack multiple games into one game state)
	
	public double gold;					// The primary resource of the networks, gained by fees and ad revenue. 1 Money = 1000â‚¬
	public double code; 				// Secondary resource created by employed coders
	public double data;					// Secondary resource created by user activity
	public double insight;				// Secondary resource created by data scientists and marketing staff
	
	public double alignmentPrice;		// The price range of the platform (0=Budget, 1=Luxury)
	public double alignmentProduct;		// The product type of the platform (0=Practical stuff, 1=Art)
	
	public double buyerPriceSign;		// The price a buyer must pay to register
	public double buyerPriceSub;		// The price a buyer must pay per month (1 turn equals 12 months)
	public double buyerPriceAction;		// The price a buyer must pay when making a purchase
	public double buyerPriceComission;	// The commission a buyer must pay when making a purchase
	public boolean buyerFreemium;		// 1 if platform offers two account options to buyers, 0 otherwise
	
	public double sellerPriceSign;		// The price a seller must pay to register
	public double sellerPriceSub;		// The price a seller must pay per month (1 turn equals 12 monts)
	public double sellerPriceAction;	// The price a seller must pay when making a deal
	public double sellerPriceComission;	// The commission a seller must pay when making a deal
	public boolean sellerFreemium;		// 1 if platform offers two account options to sellers, 0 otherwise
	
	public double buyerAdActivityPPC;	// The amount of PPC ads shown to buyers (0=None, 1=Excessive)
	public double sellerAdActivityPPC;	// The amount of PPC ads shown to sellers (0=None, 1=Excessive)
	public double buyerAdActivityCPM;	// The amount of CPM ads shown to buyers (0=None, 1=Excessive)
	public double sellerAdActivityCPM;	// The amount of CPM ads shown to sellers (0=None, 1=Excessive)
	
	// Amount of buyers and sellers the platform can handle. Heavily dependent on QoL features the platform offers
	// Soft cap is at 100%. If the platform exceeds 100% pop cap, network effects of additional users show diminishing returns
	// Hard cap is at 200%. If the platform reaches 200% pop cap, network effects max out
	
	public double buyerPopCap; 			
	public double sellerPopCap;
	
	// Initial reputation is 75% with a weight of 100 users. If a platform has 2 users with 100% reputation factor, the
	// overall reputation would thus not be 100% but a number slightly above 75%.
	
	public double reputationBase=75;
	public double reputationBaseWeight=100;
	public double reputation;
	
	// Employees cost 25 money per turn, but give important stat boosts. The maximum amount of employees
	// is 15 per trade, thus 60 in total.
	
	public int mods;					// Mods reduce threats from trolls
	public int coders;					// Coders produce code (base rate: 50 per turn per coder)
	public int marketers;				// Marketers increase various user related stats (2% each) and produce insight (base rate: 5 per turn)
	public int dataScientists;			// Data Scientists convert raw data into insight (base rate: 50 to 15)
	
	LinkedList<Tech> techs;				// Tech tree state of this platform
	
	// tech related factors
	
	public double factorCodeGeneration=50.0;		// Code generation per coder per turn
	public double factorDataGeneration=1.00;		// Multiplier for data generated by user interaction
	public double factorDataConversion=15.00;		// Insight created by data scientists from 50 raw data
	public double factorCooldownBuyers=1.00;		// Probability that a buyer is exhausted after 1 deal
	public double factorCooldownSellers=1.00;		// Probability that a buyer is exhausted after 1 deal
	public double factorMatchingDistance=0.20;		// Higher = easier matchmaking between buyers and sellers
	public double factorMatchQualityScaling=0.00;	// If greater zero, highly rated sellers attract more buyers
	public double factorAdDisutility=1.00;			// General disutility created by ads
	public double factorAdAccuracy=1.00; 			// Boosts click through rate when greater than 1.00
	public double factorCostDisutility=1.00;		// General disutility created by fees of all kind	
	public double factorFakeReviewSupression=0.00;	// Probability that a fake review is stopped
	public double factorCheatSupression=0.00;		// Probability that an attempted fraud is stopped
	public double factorSignalGeneration=0.50;		// Probability that a buyer gives a review (if function is researched)
	public double factorBuyerBeta=0.05;				// Scaling of buyer side network effects
	public double factorSellerBeta=0.15;			// Scaling of seller side network effects
	public double factorSkillBonus=1.00;			// Effect of seller skill on buyer happiness
	public double factorMarketerBonus=1.00;			// Bonus utility by marketing staff (2% per marketer)
	
	public double intrinsicBuyerValue=2;			// Utility of an empty platform to buyers
	public double intrinsicSellerValue=2;			// Utility of an empty platform to sellers
	
	// stats used by ExportHTML class
	
	public int scoreGold;
	public int scoreInsight;
	public int scoreTech;
	public int scorePopulation;
	public int scoreActivity;
	public int scoreReputation;
	public int score;
	
	public double incomeSignUp;
	public double incomeSub;
	public double incomeAction;
	public double incomeAds;
	public double incomeSelling;
	public double income;
	
	public double costSignUp;
	public double costsOperation;
	public double costsInvest;
	public double costs;
	
	public int popBuyers;
	public int popSellers;
	public int transactions;
	
	public int[] eventDecisions;	// A vector of decisions made for the events on turn 0,1,2,...
	
	/**
	 * Creates a new player with the given name and places it in the given division
	 */
	public Player(String name, Division division) {
		this.name = name;
		this.division = division;
		this.techs = new LinkedList<Tech>();
		TechTree.getInstance().createTechTree(this);
		
		// without any upgrades, a platform supports 100 buyers and 40 sellers, putting the initial
		// hard cap at 200 buyers and 80 sellers
		
		buyerPopCap=100;
		sellerPopCap=40;
		
		// players start with 300 money and 150 code
		
		alignmentPrice=0.5;
		alignmentProduct=0.5;
		reputation = 0.75;
		gold = 300;
		code = 150;
		data = 0;
		insight = 0;
		
		eventDecisions = new int[15];
	}
	
	
	/**
	 * The income and cost variables track the amount of money earned and spend by this player.
	 * At the beginning of each round, these variables are reset to zero.
	 */
	public void clearRoundData() {
		
		income=0;
		incomeAction=0;
		incomeAds=0;
		incomeSelling=0;
		incomeSignUp=0;
		incomeSub=0;
		
		costs=0;
		costSignUp=0;
		costsInvest=0;
		costsOperation=0;
	
	}
	
	/**
	 * This method registers revenue (positive amount) and expenditure (negative amount)
	 * @param amount The amount of money gained or spent
	 * @param category The type of revenue (subs, ads, ...) or expenditure
	 */
	public void gain(double amount,int category) {
		
		if(amount!=0)Logger.getInstane().log(getName() + " gain of "+amount+" by category "+category, 4);
		
		if(eventDecisions[1]==2 && amount>0)amount=amount*0.85; // debuff from selling equity in an early game event
		if(eventDecisions[2]==1 && amount>0)amount=amount*1.05; // buff from hiring controlling student in an early game event
		
		gold=gold+amount;
		
		if(amount>0) {
			if(category==0)incomeSignUp=incomeSignUp+amount;
			if(category==1)incomeSub=incomeSub+amount;
			if(category==2)incomeAction=incomeAction+amount;
			if(category==3)incomeAds=incomeAds+amount;
			if(category==4) {
				incomeSelling=incomeSelling+amount;
			}
		}
		
		if(amount<0) {
			if(category==0)costSignUp=costSignUp+amount;
			if(category==1)costsOperation=costsOperation+amount;
			if(category==2)costsInvest=costsInvest+amount;
		}
		
	}

	
	/**
	 * Pays employees if possible and fires them if not. After employees are paid, their specific effects are
	 * applied to the platform.
	 */
	public void employeeAction() {
		
		// Coders generate code (base rate: 50 per turn)
		
		coders = (int) Math.min(gold/Constants.salary, coders);		
		code = code + coders*factorCodeGeneration;
		gain(-coders * Constants.salary,1);		
		Logger.getInstane().log(getName() + " gains "+coders*factorCodeGeneration+" code by "+coders+ " coders", 2);
		
		// Mods reduce probability of trolling 
		
		mods = (int) Math.min(gold/Constants.salary, mods);		
		factorFakeReviewSupression = factorFakeReviewSupression + 0.20*mods;
		factorCheatSupression = factorCheatSupression + 0.20*mods;
		gain(- mods * Constants.salary,1);
		Logger.getInstane().log(getName() + " gains "+0.20*mods+" supression by "+mods+ " moderators", 2);
		
		// Marketers generate insight (base rate: 5 per turn) and give various little buffs to everything customer related
		
		marketers = (int) Math.min(gold/Constants.salary, marketers);		
		insight = insight + Constants.marketerEfficacy*marketers;
		factorAdAccuracy = factorAdAccuracy + 0.02*marketers;
		factorAdDisutility = factorAdDisutility - 0.02*marketers;
		factorMarketerBonus = 1.00 + 0.02*marketers;
		gain(- marketers * Constants.salary,1);
		Logger.getInstane().log(getName() + " gains "+insight+" insight by "+marketers+ " marketers", 2);
		
		// Data scientists convert raw data into insight
		
		dataScientists = (int) Math.min(gold/Constants.salary, dataScientists);		
		double conversion = Math.min(data,dataScientists*50);
		insight = insight + conversion*(factorDataConversion/50);
		data = data - conversion;
		gain(- dataScientists * Constants.salary,1);
		Logger.getInstane().log(getName() + " gains "+conversion*(factorDataConversion/50)+" insight by "+dataScientists+ " DataScientists", 2);
		Logger.getInstane().log(getName() + " loses "+conversion+" data by "+dataScientists+ " DataScientists", 2);
	}
	
	/**
	 * A platform can sell raw data and insight. The latter is far more valuable
	 * @param d The amount of raw data sold at 0.1 money per data unit (0.25 with buff from mid-game event)
	 * @param i The amount of insight sold at 0.5 money per data unit (1.5 with buff from mid-game event)
	 */
	public void sellData(double d, double i) {
		
		d=Math.min(d, data);
		i=Math.min(i, insight);
		
		data=data-d;
		insight=insight-i;
		
		if(eventDecisions[5]==3) {
			gain((d*0.25+i*1.5),4);
			Logger.getInstane().log(getName() + " gains "+(d*0.25+i*1.5)+" gold by selling "+d+ " data and " + i + " insight", 2);
		}else {
			gain((d*0.1+i*0.5),4);
			Logger.getInstane().log(getName() + " gains "+(d*0.1+i*0.5)+" gold by selling "+d+ " data and " + i + " insight", 2);
		}
		
		
	}
	
	/**
	 * Calcuates the score of this platform using 6 different categories. 
	 * Maximum score is 10 stars per category and thus 60 stars in total.
	 */
	public void ratePlayer() {
		
		income=incomeSignUp+incomeSub+incomeAction+incomeAds+incomeSelling;
		costs=costsOperation+costsInvest+costSignUp;
		
		// Gold Rating
		
		scoreGold=0;
		if(gold>50)scoreGold=1;
		if(gold>100)scoreGold=2;
		if(gold>250)scoreGold=3;
		if(gold>500)scoreGold=4;
		if(gold>1000)scoreGold=5;
		if(gold>2000)scoreGold=6;
		if(gold>3000)scoreGold=7;
		if(gold>5000)scoreGold=8;
		if(gold>7500)scoreGold=9;
		if(gold>10000)scoreGold=10;
		
		// Data Rating
		
		scoreInsight=0;
		if(insight>50)scoreInsight=1;
		if(insight>100)scoreInsight=2;
		if(insight>250)scoreInsight=3;
		if(insight>500)scoreInsight=4;
		if(insight>1000)scoreInsight=5;
		if(insight>2000)scoreInsight=6;
		if(insight>3000)scoreInsight=7;
		if(insight>5000)scoreInsight=8;
		if(insight>7500)scoreInsight=9;
		if(insight>10000)scoreInsight=10;
		
		// Tech Score
		int count=0;
		for(Tech tech:techs) {
			if(tech.active)count++;
		}
		
		scoreTech=0;
		if(count>=1)scoreTech=1;
		if(count>=2)scoreTech=2;
		if(count>=3)scoreTech=3;
		if(count>=5)scoreTech=4;
		if(count>=8)scoreTech=5;
		if(count>=10)scoreTech=6;
		if(count>=12)scoreTech=7;
		if(count>=16)scoreTech=8;
		if(count>=20)scoreTech=9;
		if(count>=25)scoreTech=10;
		
		// Population Score
		
		count=0;
		popBuyers=0;
		popSellers=0;
		double reputationSum=0;
		
		for(Buyer buyer:division.getBuyers()) {
			if(buyer.player!=null && buyer.player.equals(this)) {
				reputationSum=reputationSum+buyer.satisfaction;
				popBuyers++;
				count++;
			}
		}
		for(Seller seller:division.getSellers()) {
			if(seller.player!=null && seller.player.equals(this)) {
				reputationSum=reputationSum+seller.satisfaction;
				popSellers++;
				count++;
			}
		}
		
		scorePopulation=0;
		if(count>=20)scorePopulation=1;
		if(count>=50)scorePopulation=2;
		if(count>=100)scorePopulation=3;
		if(count>=250)scorePopulation=4;
		if(count>=500)scorePopulation=5;
		if(count>=1000)scorePopulation=6;
		if(count>=2500)scorePopulation=7;
		if(count>=4000)scorePopulation=8;
		if(count>=8000)scorePopulation=9;
		if(count>=12000)scorePopulation=10;
		
		// Activity Score
		
		scoreActivity=0;
		if(transactions>=200)scoreActivity=1;
		if(transactions>=500)scoreActivity=2;
		if(transactions>=1000)scoreActivity=3;
		if(transactions>=2500)scoreActivity=4;
		if(transactions>=5000)scoreActivity=5;
		if(transactions>=10000)scoreActivity=6;
		if(transactions>=25000)scoreActivity=7;
		if(transactions>=50000)scoreActivity=8;
		if(transactions>=100000)scoreActivity=9;
		if(transactions>=150000)scoreActivity=10;
		
		// Reputation Score including overcrowding penalties
		
		for(Buyer buyer:division.getBuyers()) {
			if(buyer.player!=null && buyer.player.equals(this)) {
				if(popBuyers>buyerPopCap)buyer.satisfaction = buyer.satisfaction-0.01;
				if(popBuyers>1.5*buyerPopCap)buyer.satisfaction = buyer.satisfaction-0.01;
				if(popBuyers>2.0*buyerPopCap)buyer.satisfaction = buyer.satisfaction-0.01;
			}
		}
		for(Seller seller:division.getSellers()) {
			if(seller.player!=null && seller.player.equals(this)) {
				if(popSellers>sellerPopCap)seller.satisfaction = seller.satisfaction-0.01;
				if(popSellers>1.5*sellerPopCap)seller.satisfaction = seller.satisfaction-0.01;
				if(popSellers>2.0*sellerPopCap)seller.satisfaction = seller.satisfaction-0.01;
			}
		}
		
		reputation = (reputationSum+reputationBase)/(popBuyers+popSellers+reputationBaseWeight);
		
		if(reputation>1)reputation=1;
		if(reputation<0)reputation=0;
		
		if(eventDecisions[4]==1)reputation=reputation+0.1;
		if(eventDecisions[4]==3)reputation=reputation-0.1;	
		
		if(reputation>1)reputation=1;
		if(reputation<0)reputation=0;
		
		scoreReputation=0;
		if(reputation>=0.25)scoreReputation=1;
		if(reputation>=0.33)scoreReputation=2;
		if(reputation>=0.50)scoreReputation=3;
		if(reputation>=0.60)scoreReputation=4;
		if(reputation>=0.70)scoreReputation=5;
		if(reputation>=0.75)scoreReputation=6;
		if(reputation>=0.80)scoreReputation=7;
		if(reputation>=0.85)scoreReputation=8;
		if(reputation>=0.90)scoreReputation=9;
		if(reputation>=0.95)scoreReputation=10;
		
		score = scoreGold + scoreInsight + scoreTech + scorePopulation + scoreActivity + scoreReputation;

		
	}
	
	/**
	 * Handles the first two events. The mid and late game events are handled in other parts of the
	 * code, most likely in the TechTree class.
	 */
	public void events() {
		
	    Logger.instance.log("Player " + getName() + " decidies "+ eventDecisions[division.getTurn()] + " for turn " + division.getTurn(),2);
		
		// Round 1 - Launch Decision
		
		if(division.getTurn()==0) {
			if(eventDecisions[0]==1 && gold>=50) {
				gold=gold-50;			
			}else if(eventDecisions[0]==1 && gold<50) {
				eventDecisions[0]=2;
			}else if(eventDecisions[0]==3) {
				insight=insight+50;
				code=code+75;
			}
		}
		
		// Round 2 - Finance Decision
		
		if(division.getTurn()==1) {
			if(eventDecisions[1]==1)gold=gold+100;
			if(eventDecisions[1]==2)gold=gold+150;
			if(eventDecisions[1]==3) {
				gold=gold+50;
				for(Player p:division.players) {
					if(!p.equals(this)) {
						p.code = p.code+25;
					}
				}
			}
		}
		
		if(eventDecisions[1]==1 && division.getTurn()>1 && division.getTurn()<8) {
			gold=gold-15;
		}
		
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public LinkedList<Tech> getTechs() {
		return techs;
	}

	public void setTechs(LinkedList<Tech> techs) {
		this.techs = techs;
	}
	
}
